---
title: "Adding OAuth to Your Tool Plugin"
---

![b0e673ba3e339b31ac36dc3cd004df04787bcaa64bb6d2cac6feb7152b7b515f.png](/images/b0e673ba3e339b31ac36dc3cd004df04787bcaa64bb6d2cac6feb7152b7b515f.png)

This guide teachs you how to build plugins that support [OAuth](https://oauth.net/2/). OAuth is a better way to authorize tool plugins that need to access user data from third-party services, like Gmail or GitHub. Instead of requiring the user to manually enter API keys, OAuth lets the tool to act on behalf of the user with their explicit consent.

### Creating an OAuth App

You usually need to register an OAuth app at the third-party service so the service knows who (i.e. your Dify instance) is requesting authorizations. Here we use Gmail as an example. Other platforms may be different.

1. **Create a Google Cloud Project**:
   - Go to [Google Cloud Console](https://console.cloud.google.com) and create a new project, or select existing one
   - Enable the required APIs (e.g., Gmail API, Google Drive API)
2. **Configure OAuth Consent Screen**:
   - Navigate to "APIs & Services" → "OAuth consent screen"
   - Choose "External" user type for public plugins
   - Fill in application name, user support email, and developer contact
   - Add authorized domains if needed
   - For testing: Add test users in the "Test users" section

## Implementation

### 1. Define OAuth Schema in provider manifest

The provider manifest definitions tell Dify what credentials your plugin OAuth needs and what the OAuth flow will produce. Two schemas are required for setting up OAuth:

#### client_schema

What users configure from their OAuth app:

```yaml
oauth_schema:
  client_schema:
    - name: "client_id"
      type: "secret-input"
      required: true
      url: "https://developers.google.com/identity/protocols/oauth2"
    - name: "client_secret"
      type: "secret-input" 
      required: true
```

<Info>
  The `url` field links directly to help documentations for the third-party service. This helps confusing users.
</Info>

Dify manages OAuth apps for popular verified plugins on Dify Cloud. Your `client_schema` exists, but users may never see it.

- **Self-Hosted**: Users must configure OAuth apps themselves. Your `url` field becomes critical.

#### credentials_schema

What OAuth produces (Dify manages these):

```yaml
# also under oauth_schema
  credentials_schema:
    - name: "access_token"
      type: "secret-input"
    - name: "refresh_token"
      type: "secret-input"
    - name: "expires_at"
      type: "secret-input"
```

<Info>
  Include both `oauth_schema` and `credentials_for_provider` to offer OAuth \+ API key options.
</Info>

### 2. Implement Authorization URL Generation

**Purpose**: Create the URL where users grant permissions to your plugin.

```python
def _oauth_get_authorization_url(self, redirect_uri: str, system_credentials: Mapping[str, Any]) -> str:
    params = {
        "client_id": system_credentials["client_id"],
        "redirect_uri": redirect_uri,
        "scope": "user:email repo",
        "access_type": "offline",  # Gets refresh token
    }
    return f"https://github.com/login/oauth/authorize?{urllib.parse.urlencode(params)}"
```

**Input**:

- `redirect_uri`: Dify's callback URL (don't modify)
- `system_credentials`: Contains `client_id`, `client_secret` from user's OAuth app

**Output**: Complete authorization URL string

**Critical parameters**:

- `access_type=offline`: Required for refresh tokens
- `prompt=consent`: Forces reauth when scopes change

### 3. Exchange Code for Tokens

**Purpose**: Convert the authorization code into usable access tokens.

```python
def _oauth_get_credentials(self, redirect_uri: str, system_credentials: Mapping[str, Any], request: Request) -> ToolOAuthCredentials:
    code = request.args.get("code")
    
    response = requests.post("https://github.com/login/oauth/access_token", data={
        "client_id": system_credentials["client_id"],
        "client_secret": system_credentials["client_secret"],
        "code": code,
    }, headers={"Accept": "application/json"})
    
    tokens = response.json()
    expires_at = int(time.time() + tokens.get("expires_in", 3600))
    
    return ToolOAuthCredentials(
        credentials={"access_token": tokens["access_token"], "expires_at": expires_at},
        expires_at=expires_at
    )
```

**Input**:

- `request`: Contains authorization `code` in query parameters
- Same `redirect_uri` and `system_credentials` from step 2

**Output**: `ToolOAuthCredentials` object with:

- `credentials`: Dict containing tokens
- `expires_at`: Unix timestamp for token expiry

**Error handling**: Raise `ToolProviderOAuthError` if token exchange fails.

### 4. Handle Token Refresh

**Purpose**: Get new access tokens when current ones expire.

```python
def _oauth_refresh_credentials(self, redirect_uri: str, system_credentials: Mapping[str, Any], credentials: Mapping[str, Any]) -> ToolOAuthCredentials:
    response = requests.post("https://oauth.service.com/token", data={
        "grant_type": "refresh_token",
        "refresh_token": credentials["refresh_token"],
        "client_id": system_credentials["client_id"],
    })
    
    tokens = response.json()
    expires_at = int(time.time() + tokens["expires_in"])
    
    return ToolOAuthCredentials(
        credentials={"access_token": tokens["access_token"], "expires_at": expires_at},
        expires_at=expires_at
    )
```

**Input**:

- `credentials`: Current credentials containing `refresh_token`
- Same `system_credentials` from OAuth app

**Output**: New `ToolOAuthCredentials` with fresh `access_token`

**Note**: Some services don't provide refresh tokens. Handle gracefully.

### 5. Validate Credentials Work

**Purpose**: Test credentials by making a real API call.

```python
def _validate_credentials(self, credentials: dict[str, Any]) -> None:
    response = requests.get("https://api.github.com/user", 
                          headers={"Authorization": f"Bearer {credentials['access_token']}"})
    if response.status_code != 200:
        raise ToolProviderCredentialValidationError("Invalid credentials")
```

**Input**: Credentials dict containing `access_token` **Output**: None (raises exception if invalid)

**Purpose**: Called when users connect and periodically to verify credentials still work.

### 6. Access Tokens in Your Tools

**Purpose**: Use OAuth credentials to make authenticated API calls.

```python
class YourTool(BuiltinTool):
    def _invoke(self, user_id: str, tool_parameters: dict[str, Any]) -> ToolInvokeMessage:
        access_token = self.runtime.credentials["access_token"]
        
        response = requests.get("https://api.service.com/data",
                              headers={"Authorization": f"Bearer {access_token}"})
        return self.create_text_message(response.text)
```

**Key**: `self.runtime.credentials` automatically provides the current user's tokens. Dify handles refresh automatically.

## OAuth App Setup by Service

### Google (Gmail, Drive, Calendar)

1. **Google Cloud Console** → Create Project
2. **APIs & Services** → Enable required APIs (Gmail, Drive, etc.)
3. **OAuth Consent Screen**:
   - External user type
   - Add test users during development
   - Submit for verification for production
4. **Credentials** → OAuth 2.0 Client ID:
   - Web application
   - Authorized redirect URIs: `https://your-dify-domain.com/console/api/oauth/plugin/{plugin-id}/{provider-name}/{tool-name}/callback`

### GitHub

1. **Settings** → Developer settings → OAuth Apps
2. **New OAuth App**:
   - Authorization callback URL: `https://your-dify-domain.com/console/api/oauth/plugin/{plugin-id}/{provider-name}/{tool-name}/callback`
   - Save Client ID and Client Secret

### Notion

1. **My integrations** → New integration
2. **OAuth Domain & URIs**:
   - Redirect URI: `https://your-dify-domain.com/console/api/oauth/plugin/{plugin-id}/{provider-name}/{tool-name}/callback`
3. **Capabilities**: Select required permissions

## Debugging OAuth Issues

### 403 Forbidden

**Root cause**: Scope mismatch or unverified app

- Check API enablement in service console
- Verify OAuth scopes match API operations
- Add test users if app is unverified
- Re-authorize after scope changes

### Redirect URI Mismatch

**Root cause**: Exact string mismatch

- Protocol (https vs http)
- Domain casing
- Trailing slashes
- Plugin ID accuracy

### No Refresh Token

**Root cause**: Missing offline access request

```python
# Wrong
params = {"scope": "user:email"}

# Right  
params = {
    "scope": "user:email",
    "access_type": "offline",
    "prompt": "consent"
}
```

### Token Refresh Fails

**Root cause**: Scope changes invalidate refresh tokens

- Users must re-authorize completely
- Refresh tokens can expire (Google: 6 months inactive)
- Some services don't provide refresh tokens

## Production Considerations

**Rate Limits**: Implement exponential backoff for API calls **Error Handling**: Graceful degradation when tokens expire **Scope Minimization**: Request only necessary permissions **Security**: Never log access tokens **User Communication**: Clear error messages for re-authorization

**Testing Strategy**:

1. Test with multiple user accounts
2. Test token expiry scenarios
3. Test scope changes requiring re-auth
4. Test Self-Hosted vs SaaS deployment modes

The biggest mistake developers make is not understanding the deployment architecture upfront. Choose your target deployment model first, then implement accordingly.